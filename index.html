<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>阿黄的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="EveryDay is the day">
<meta property="og:type" content="website">
<meta property="og:title" content="阿黄的博客">
<meta property="og:url" content="https://ahuang007.github.io/index.html">
<meta property="og:site_name" content="阿黄的博客">
<meta property="og:description" content="EveryDay is the day">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="阿黄的博客">
<meta name="twitter:description" content="EveryDay is the day">
  
    <link rel="alternative" href="/atom.xml" title="阿黄的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.jpg">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/img/me.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">ahuang</a></h1>
		</hgroup>

		
		<p class="header-subtitle">岁月无声</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
							<li><a href="/photo">相册</a></li>
				        
							<li><a href="/about">关于</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="http://github.com/ahuang007" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/ahuang007" title="weibo">weibo</a>
					        
								<a class="rss" target="_blank" href="http://blog.sina.com.cn/u/2137822390" title="rss">rss</a>
					        
								<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/huang-li-jun-7" title="zhihu">zhihu</a>
					        
								<a class="mail" target="_blank" href="https://mail.qq.com/" title="mail">mail</a>
					        
								<a class="facebook" target="_blank" href="/419637330@qq.com" title="facebook">facebook</a>
					        
								<a class="google" target="_blank" href="/419637330@qq.com" title="google">google</a>
					        
								<a class="twitter" target="_blank" href="/ahuang27374018" title="twitter">twitter</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/article/" style="font-size: 10px;">article</a> <a href="/tags/it/" style="font-size: 20px;">it</a> <a href="/tags/life/" style="font-size: 13.33px;">life</a> <a href="/tags/linux/" style="font-size: 10px;">linux</a> <a href="/tags/lua/" style="font-size: 13.33px;">lua</a> <a href="/tags/技术/" style="font-size: 16.67px;">技术</a> <a href="/tags/技术，-c/" style="font-size: 10px;">技术， c++</a> <a href="/tags/技术，-数据库/" style="font-size: 10px;">技术， 数据库</a> <a href="/tags/技术，-数据结构/" style="font-size: 13.33px;">技术， 数据结构</a> <a href="/tags/技术，-算法/" style="font-size: 10px;">技术， 算法</a> <a href="/tags/技术，linux/" style="font-size: 10px;">技术，linux</a> <a href="/tags/技术，算法/" style="font-size: 10px;">技术，算法</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://luucio.com/">晓晓的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.hawkk.cn/">科长的的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.codingnow.com/">云风的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://tofindme.github.io">易斌的博客</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">我就是我，是颜色不一样的烟火…</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">ahuang</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img lazy-src="/img/me.jpg" class="js-avatar">
				
			</div>
			<hgroup>
			  <h1 class="header-author">ahuang</h1>
			</hgroup>
			
			<p class="header-subtitle">岁月无声</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
					<li><a href="/photo">相册</a></li>
		        
					<li><a href="/about">关于</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="http://github.com/ahuang007" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/ahuang007" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="http://blog.sina.com.cn/u/2137822390" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/huang-li-jun-7" title="zhihu">zhihu</a>
			        
						<a class="mail" target="_blank" href="https://mail.qq.com/" title="mail">mail</a>
			        
						<a class="facebook" target="_blank" href="/419637330@qq.com" title="facebook">facebook</a>
			        
						<a class="google" target="_blank" href="/419637330@qq.com" title="google">google</a>
			        
						<a class="twitter" target="_blank" href="/ahuang27374018" title="twitter">twitter</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-求一个正整数二进制表示有多少个1" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/02/20/求一个正整数二进制表示有多少个1/" class="article-date">
  	<time datetime="2019-02-20T07:31:21.000Z" itemprop="datePublished">2019-02-20</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/02/20/求一个正整数二进制表示有多少个1/">数1</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="问题：求一个正整数的二进制表示含有多少个1"><a href="#问题：求一个正整数的二进制表示含有多少个1" class="headerlink" title="问题：求一个正整数的二进制表示含有多少个1"></a>问题：求一个正整数的二进制表示含有多少个1</h4><p>例如：uint32_t i = 58585858;</p>
<p>i的二进制表示为：</p>
<p>0000 0011 0111 1101 1111 0011 0000 0010</p>
<p>于是，i的二进制表示包含15个1 </p>
<p>解决方法以及优化思路如下：</p>
<h4 id="一-位移法"><a href="#一-位移法" class="headerlink" title="一 位移法"></a>一 位移法</h4><ul>
<li><p>思路：既然输入n是uint32,每次去n的最低位，判断是不是1，位移32次，循环判断即可</p>
</li>
<li><p>伪代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">do</span> &#123;</div><div class="line">    <span class="keyword">if</span>((n&amp;<span class="number">1</span>)==<span class="number">1</span>)&#123;</div><div class="line">        result++;</div><div class="line">    &#125;</div><div class="line">    n &gt;&gt;= <span class="number">1</span>;</div><div class="line">    i++;</div><div class="line">&#125; <span class="keyword">while</span>(i&lt;<span class="number">32</span>);</div></pre></td></tr></table></figure>
</li>
<li><p>分析：不管n的二进制表示里包含多少个1，都需要循环计算32次，比较耗时。有没有可能每次消除掉一个1，这样降低计算次数呢？见方法二。</p>
</li>
</ul>
<h4 id="二-求与法"><a href="#二-求与法" class="headerlink" title="二 求与法"></a>二 求与法</h4><ul>
<li><p>观察一下n与n-1这两个数的二进制表示：</p>
<ul>
<li>最末位一个1会变成0</li>
<li>最末位一个1之后的0会全部变成1</li>
<li>其他位相同</li>
</ul>
<p>​       例1:     x = 1011 1010</p>
<p>​            x-1 = 1011 1001</p>
<p>​       x &amp; (x-1) = 1011 1000</p>
<p>​    于是 n&amp;(n-1)这个操作，可以起到“消除最后一个1”的功效 </p>
</li>
<li><p>思路：逐步通过n&amp;(n-1)，来消除n末尾的1，消除了多少次，就有多少个1</p>
</li>
<li><p>伪代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span>(n)&#123;</div><div class="line">    result++;</div><div class="line">    n &amp;= (n<span class="number">-1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>分析： 这个方法，n的二进制表示有多少个1，就会计算多少次。总的来说，n的长度是32bit,如果n的值选取完全随机，平均期望由16个1构成，平均下来16次，节省一半的计算量。</p>
<ul>
<li>同理： “如何快速判断一个正整数是不是2的x次幂” <ul>
<li>巧妙的解法是： <code>return !(n&amp;(n-1))</code> 即如果n是2的x次幂，二进制表示只有一个1.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="三-查表法"><a href="#三-查表法" class="headerlink" title="三 查表法"></a>三 查表法</h4><ul>
<li><p>空间换时间：是<strong>算法优化中最常见的手段</strong>,如果有相对充裕的内存，可以有更快的算法。</p>
</li>
<li><p>思路：一个uint32的正整数n,一旦n的值确定，n的二进制表示中包含多少个1也就确定了，理论上不用再计算</p>
<ul>
<li>1的二进制表示中包含1个1                     <code>result[1]=1</code></li>
<li>2的二进制表示中包含1个1                          <code>result[2]=1</code></li>
<li>3的二进制表示中包含2个1                          <code>result[2]=1</code></li>
<li>…</li>
<li>5858585858的二进制表示中包含15个1    <code>result[58585858]=15</code></li>
</ul>
</li>
<li><p>伪代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span> result[n];</div></pre></td></tr></table></figure>
</li>
<li><p>分析： 查表法的好处是，时间复杂度为o(1)，潜在的问题是，需要很大的内存</p>
</li>
<li><p>内存分析：假如被分析的整数是uint32,打表数组需要记录2^32个正整数的结果。</p>
<p>n的二进制表示最多包含32个1，存储结果的计数，使用5个bit就可以了 <code>10000[二进制] = 32[十进制]</code></p>
<p>所以，共需要内存<code>2^32 X 5bit = 2^30 X (2^2X5/8)byte = 2.5GB</code></p>
</li>
</ul>
<h4 id="四-二次查表法"><a href="#四-二次查表法" class="headerlink" title="四 二次查表法"></a>四 二次查表法</h4><ul>
<li><p>查表法，非常快，只查询一次，但内存消耗太大</p>
</li>
<li><p>算法设计本身是一个时间复杂度和空间复杂度的折中。<strong>增加计算次数，往往能够减少存储空间</strong>。</p>
</li>
<li><p>思路：</p>
<p>(1) 把uint32的正整数n，分解为低16位正整数n1,和高16位正整数n2;</p>
<p>(2) n1查一次表，其二进制表示中包含a个1；</p>
<p>(3) n2查一次表，其二进制表示中包含b个1；</p>
<p>(4) 则 n的二进制表示包含a+b个1；</p>
</li>
<li><p>伪代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">uint16 n1 = n &amp; <span class="number">0xFFFF</span>;</div><div class="line">uint16 n2 = (n&gt;&gt;<span class="number">16</span>)&amp;<span class="number">0xFFFF</span>;</div><div class="line"><span class="keyword">return</span> result[n1]+result[n2];</div></pre></td></tr></table></figure>
</li>
<li><p>分析：增加一倍的计算量。内存空间是不是对应减少一半呢？</p>
</li>
<li><p>内存分析：被分析的整数变成uint16,打表数组需要记录2^16个正整数的结果</p>
<p>n1和n2的二进制表示最多包含16个1，存储结果的计数，只用4个bit即可。<code>1000[二进制] = 16[十进制]</code></p>
<p>所以，共需要内存 <code>2^16 X 4bit = 2^10 X (2^6X4/8) byte = 32KB</code></p>
</li>
<li><p>计算量多了1次（1倍），内存占用却由2.5G降到了32K（1万多倍）</p>
</li>
</ul>
<h4 id="五-总结"><a href="#五-总结" class="headerlink" title="五 总结"></a>五 总结</h4><ul>
<li>数1并不难，但其思路优化过程，并不简单：<ul>
<li>(1) 位移法 32次计算；</li>
<li>(2)n&amp;(n-1) 能消除一个1，平均计算16次；</li>
<li>(3)查表法，1次查表，2.5G内存；</li>
<li>(4)二次查表法，2次查表，32K内存；</li>
</ul>
</li>
<li>思路比结论重要</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/技术，算法/">技术，算法</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/it/">it</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Mysql优化" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/02/19/Mysql优化/" class="article-date">
  	<time datetime="2019-02-19T07:48:21.000Z" itemprop="datePublished">2019-02-19</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/02/19/Mysql优化/">mysql优化方案总结</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="Mysql数据库优化技术"><a href="#Mysql数据库优化技术" class="headerlink" title="Mysql数据库优化技术"></a>Mysql数据库优化技术</h4><ol>
<li><p>表的设计合理化【符合3NF】</p>
</li>
<li><p>添加适当索引（index)【四种：普通索引，主键索引，唯一索引unique,全文索引】</p>
</li>
<li><p>分表技术【水平分割，垂直分割】</p>
<ul>
<li><p>水平分割：一张表不宜过多字段.比如玩家表 拆分成 玩家基本数据表 玩家vip数据表 玩家货币数据表 等</p>
</li>
<li><p>垂直分割：一张表的容量不宜过大.比如物品表，拆分成 材料表，装备表，卡牌表等</p>
</li>
</ul>
</li>
<li><p>读写分离【update/delete/add】</p>
<ul>
<li>主从（主表游戏用，有所有权限；从表给运用后台使用，只有查询权限）</li>
</ul>
</li>
<li><p>存储过程【模块化编程，可以提高速度】</p>
</li>
<li><p>对mysql配置优化【配置最大并发数my.ini,调整缓存大小】</p>
</li>
<li><p>mysql服务器硬件升级</p>
</li>
<li><p>定时去清除不需要的数据</p>
<ul>
<li>比如一年以上不活跃的玩家 或者超过1个月以上的回放记录</li>
</ul>
</li>
<li><p>定时进行碎片整理(MyISAM)</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">optimize</span> <span class="keyword">table</span> <span class="keyword">test</span>; //对myisam进行整理</div><div class="line">mysql_query("<span class="keyword">optimize</span> <span class="keyword">tables</span> <span class="keyword">test</span><span class="string">");</span></div></pre></td></tr></table></figure>
</li>
<li><p>优化sql语句：【1 尽量使用简单sql语句，用程序处理代替联合查询 2 定位慢查询 优化语句】</p>
<ul>
<li>定位慢查询   </li>
</ul>
<p><code>explain sql语句</code></p>
<p>explain可以帮助我们在不真正实现某个sql语句时，就知道mysql怎样执行sql语句的，这样利于我们去分析sql语句。</p>
</li>
</ol>
<h4 id="如何选择mysql的存储引擎"><a href="#如何选择mysql的存储引擎" class="headerlink" title="如何选择mysql的存储引擎"></a>如何选择mysql的存储引擎</h4><ul>
<li>在开发中,我们经常使用的存储引擎 myisam/innodb/memory<ul>
<li>myisam存储引擎：如果表对事务·要求不高，同时是以查询和添加为主的，考虑使用myisam存储引擎。比如bbs中的发帖表，回复表。</li>
<li>innodb存储引擎：对事务要求高，保存的数据都是重要数据，建议使用innodb。比如订单表，账号表。</li>
<li>memory存储引擎：比如数据变化频繁。不需要入库，同时又频繁的查询和修改，我们考虑使用memory，速度极快。</li>
</ul>
</li>
<li>myisam和innodb的区别：<ul>
<li>事务安全</li>
<li>查询和添加速度</li>
<li>支持全文索引</li>
<li>锁机制<ul>
<li>myisam：只有表锁，没有事务，锁粒度大，当并发高时，要等待的查询就会很多</li>
<li>innodb:有行锁和表锁。行锁是通过索引体现的：如果where条件中用到索引项，则加行锁；否则加表锁。</li>
</ul>
</li>
<li>外键：myisam不支持外键，innodb支持</li>
</ul>
</li>
</ul>
<p>####什么样的表才是符合3NF(范式)</p>
<ul>
<li><p>表的范式，是首先符合1NF,才能满足2NF,进一步满足3NF</p>
<ul>
<li>1NF：即表的列具有原子性，不可再分解，即列的信息不能分解，只有数据库是关系型数据库就自动的满足1NF.</li>
<li>2NF：表中的记录是唯一的，也就满足2NF,通常设计一个主键来实现</li>
<li>3NF：即表中不要有冗余的数据，就是说，表的信息，如果能够被推导出来，就不应该单独的设计一个字段来存放。</li>
<li>反3NF：但是没有冗余的数据库未必是最好的数据库，有时为了提高运行效率，就必须降低范式标准，适当保留冗余数据。降低范式就是增加字段，允许冗余。</li>
</ul>
</li>
</ul>
<h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><ul>
<li><p>主键添加索引：当一张表，把某个列设为主键的时候，则该列就是主键索引</p>
<p><code>alter table test add primary key (id);</code></p>
</li>
<li><p>普通索引：先创建表，然后在表上创建普通索引</p>
<p><code>create index 索引名 on 表 (列1,列名2);</code></p>
</li>
<li><p>全文索引：主要针对文件，文本的索引，比如文章，全文索引对MyISAM有用</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//创建</div><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> articles (</div><div class="line">       <span class="keyword">id</span> <span class="built_in">INT</span> AUTO_INCREMENT <span class="keyword">NOT</span> <span class="literal">NULL</span> PRIMARY <span class="keyword">KEY</span>,</div><div class="line">       title <span class="built_in">VARCHAR</span>(<span class="number">200</span>),</div><div class="line">       <span class="keyword">body</span> <span class="built_in">TEXT</span>,</div><div class="line">       FULLTEXT (title,<span class="keyword">body</span>) // 全文索引</div><div class="line">     )<span class="keyword">engine</span>=myisam <span class="keyword">charset</span> utf8;</div><div class="line">//使用全文索引</div><div class="line"><span class="keyword">select</span> * <span class="keyword">from</span> articles <span class="keyword">where</span> <span class="keyword">match</span>(title,<span class="keyword">body</span>) against(<span class="string">'database'</span>);</div></pre></td></tr></table></figure>
</li>
<li><p>唯一索引：当表的某列被指定为unique约束时，这列就是一个唯一的索引</p>
<p><code>create unique index 索引名  on 表名 (列表..);</code></p>
<p>这时，name列就是一个唯一索引。</p>
<p>unique字段可以为NULL,并可以有多个NULL，但是如果是具体内容，则不能重复。</p>
<p>主键字段，不能为NULL,也不能重复</p>
</li>
</ul>
<p>#####基本操作</p>
<ul>
<li><p>查询索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">desc 表名 【该方法的缺点是：　不能够显示索引名.】</div><div class="line"><span class="keyword">show</span> <span class="keyword">index</span>(es) <span class="keyword">from</span> 表名</div><div class="line"><span class="keyword">show</span> <span class="keyword">keys</span> <span class="keyword">from</span> 表名</div></pre></td></tr></table></figure>
</li>
<li><p>删除索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">drop</span> <span class="keyword">index</span> 索引名;</div></pre></td></tr></table></figure>
</li>
<li><p>修改索引：先删除，再重新创建</p>
</li>
</ul>
<h5 id="索引的代价："><a href="#索引的代价：" class="headerlink" title="索引的代价："></a>索引的代价：</h5><ul>
<li>占用磁盘空间</li>
<li>对数据库操作有影响，变慢<h5 id="总结：满足以下条件的字段，才应该创建索引："><a href="#总结：满足以下条件的字段，才应该创建索引：" class="headerlink" title="总结：满足以下条件的字段，才应该创建索引："></a>总结：满足以下条件的字段，才应该创建索引：</h5></li>
<li>肯定在where条件中经常使用</li>
<li>该字段的内容不是唯一的几个值（如sex就不宜加索引）</li>
<li>字段内容不是频繁变化的</li>
</ul>
<h5 id="使用索引注意事项"><a href="#使用索引注意事项" class="headerlink" title="使用索引注意事项"></a>使用索引注意事项</h5><ol>
<li><p>对于创建的多列索引，只要查询条件使用了最左边的列，则索引一般就会被使用,反之就不会使用到索引</p>
</li>
<li><p>对于使用like的查询，不会使用到索引</p>
</li>
<li><p>如果条件中有or，即使其中有条件待索引也不会使用。</p>
</li>
<li><p>如果列类型是字符串，那一定要在条件中奖数据使用引号引用起来，否则不使用索引</p>
</li>
<li><p>如果mysql估计使用全表扫描要比使用引用快，则不使用索引。</p>
</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/技术，-数据库/">技术， 数据库</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/it/">it</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-TopK" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/02/18/TopK/" class="article-date">
  	<time datetime="2019-02-18T07:16:21.000Z" itemprop="datePublished">2019-02-18</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/02/18/TopK/">TopK</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="TopK问题描述"><a href="#TopK问题描述" class="headerlink" title="TopK问题描述"></a>TopK问题描述</h4><p>从arr[1,n]这n个数中，找出最大的k个数，这就是经典的TopK问题</p>
<p>示例：从arr[1,12]={5,3,7,1,8,2,9,4,7,2,6,6} 这n=12个数中,找出最大的k=5个</p>
<h5 id="（一）排序"><a href="#（一）排序" class="headerlink" title="（一）排序"></a>（一）排序</h5><p>​    思路：将n个数排序之后，取出最大的k个，即为所得。</p>
<ul>
<li><p>伪代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sort(arr,<span class="number">1</span>,n);</div><div class="line"><span class="keyword">return</span> arr[<span class="number">1</span>,k];</div></pre></td></tr></table></figure>
</li>
<li><p>时间复杂度： o(n*lg(n))  <code>nlgn为快排的时间复杂度</code></p>
</li>
<li><p>分析：明明只需要TopK，却将全局都排序了，这也是这个方法复杂度非常高的原因。</p>
</li>
<li><p>优化思路：那能不能不全局排序，而只局部排序呢？见方法（二）</p>
</li>
</ul>
<h5 id="（二）局部排序"><a href="#（二）局部排序" class="headerlink" title="（二）局部排序"></a>（二）局部排序</h5><p>​    思路：不再全部排序，只对最大的k个排序.</p>
<p>​    冒泡法，每冒一个泡，找出最大值，冒k个泡，就能得到TopK.</p>
<ul>
<li><p>伪代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(i=<span class="number">1</span> to k)&#123;</div><div class="line">    bubble_find_max(arr);</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> arr[<span class="number">1</span>,k];</div></pre></td></tr></table></figure>
</li>
<li><p>时间复杂度o(n*k)</p>
</li>
<li><p>分析：冒泡，将全局排序优化为了部分排序，非TopK的元素是不需要排序的，节省了计算资源。</p>
</li>
<li><p>优化思路：这最大的K个是不是也不需要排序呢？见方法（三）</p>
</li>
</ul>
<h5 id="（三）堆"><a href="#（三）堆" class="headerlink" title="（三）堆"></a>（三）堆</h5><p>​    思路:只找到TopK,不排序TopK</p>
<p>​    先用前K个元素生成一个小顶堆，这个小顶堆用于存储当前最大的k个元素。</p>
<p>​    接着，从第k+1个元素开始扫描，和堆顶（堆中最小的元素）比较，如果被扫描的元素大于堆顶，则替换堆顶的元素，并调整堆，以保证堆内的k个元素总是当前最大的k个元素。</p>
<p>​    直到扫描完所有n-k个元素。最终堆中的k个元素，就是TopK.</p>
<ul>
<li><p>伪代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">heap[k] = make_heap(arr[<span class="number">1</span>,k])</div><div class="line"><span class="keyword">for</span>(i=k+<span class="number">1</span> to n)&#123;</div><div class="line">    adjust_heap(heap[k], arr[i]);</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> heap[k];</div></pre></td></tr></table></figure>
</li>
<li><p>时间复杂度：o(n*lg(k))</p>
</li>
<li><p>分析：堆，将冒泡的TopK排序优化为了TopK不排序，节省了计算资源。</p>
</li>
<li><p>优化思路： 有没有更快的呢？ 见方法（四）</p>
</li>
</ul>
<h5 id="（四）随机选择"><a href="#（四）随机选择" class="headerlink" title="（四）随机选择"></a>（四）随机选择</h5><ul>
<li><p>时间复杂度o(n)</p>
</li>
<li><p>快速排序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span>[]arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(low == high) <span class="keyword">return</span>;</div><div class="line">    <span class="keyword">int</span> i = partition(arr, low, high);</div><div class="line">    quit_sort(arr, low, i<span class="number">-1</span>);</div><div class="line">    quick_sort(arr, i+<span class="number">1</span>, high);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>算法核心思想：分治法.</li>
<li>时间复杂度：o(n*lg(n))</li>
</ul>
</li>
<li><p>分治法（Divide&amp;Conquer）：把一个大的问题，转化为若干个子问题，每个子问题<strong>“都”</strong>解决了，大的问题便随之解决了。<code>快排是分治法</code></p>
<p>快速排序递归时，先通过partition把数组分隔为两个部分，两个部分“都”要再次递归。</p>
</li>
<li><p>减治法（Reduce&amp;Conquer）：把一个大的问题，转化为若干个子问题，这些子问题中<strong>“只”</strong>解决一个，大的问题便随之解决了。<code>二分查找是减治法</code></p>
</li>
<li><p>二分查找（binary_search）BS</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">BS</span><span class="params">(<span class="keyword">int</span>[]arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">int</span> target)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(low&gt;high) <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    mid=(low+high)/<span class="number">2</span>;</div><div class="line">    <span class="keyword">if</span>(arr[mid]==target) <span class="keyword">return</span> mid;</div><div class="line">    <span class="keyword">if</span>(arr[mid] &gt; target)</div><div class="line">    	<span class="keyword">return</span> BS(arr,low,mid<span class="number">-1</span>,target);</div><div class="line">    <span class="keyword">else</span> </div><div class="line">    	<span class="keyword">return</span> BS(arr,mid+<span class="number">1</span>,high,target);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>一个大的问题，可以用一个mid元素，分成左半区，右半区两个问题。而左右两个问题，只需要解决其中一个，递归一次，就能够解决二分查找全局的问题。</li>
<li>时间复杂度：o(lg(n))</li>
</ul>
</li>
<li><p>随机选择(randomized_select) RS</p>
<ul>
<li><p>思路： i = partition(arr,1,n): </p>
<ul>
<li>左半区比t大，右半区比t小，中间是t</li>
<li>partition的事件复杂度：o(n)</li>
</ul>
<p>如果i&gt;k,则说明arr[i]左边的元素都大于k,于是只递归arr[1,i-1]里第k大的元素即可。</p>
<p>如果i&lt;k，则说明第k大的元素在arr[i]的右边，于是只递归arr[i+1,n]里第k-i大的元素即可。</p>
</li>
<li><p>伪代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">RS</span><span class="params">(arr,low,high,k)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(low==high) <span class="keyword">return</span> arr[low];</div><div class="line">    i=parition(arr,low,high);</div><div class="line">    temp = i-low; <span class="comment">// 数组前半部分元素个数</span></div><div class="line">    <span class="keyword">if</span>(temp&gt;=k)</div><div class="line">        <span class="keyword">return</span> RS(arr,low,i<span class="number">-1</span>,k);<span class="comment">//求前半部分第k大</span></div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="keyword">return</span> RS(arr,i+<span class="number">1</span>,high,k<span class="number">-1</span>);<span class="comment">//求后半部分第k-i大</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>TopK思路优化过程：</p>
<ul>
<li>全局排序,o(n*lg(n))</li>
<li>局部排序，只排TopK个数。o(n*k)</li>
<li>堆，Topk个数也不用排序了。o(n*lg(k))</li>
<li>分治法,每个分支“都要”递归，如：快速排序，o(n*lg(n))</li>
<li>减治法,“只要”递归一个分支，如：二分查找，o(lg(n))</li>
<li>随机选择+partition,o(n)</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/技术，-算法/">技术， 算法</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/it/">it</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-构造函数和析构函数能否为虚函数" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/02/18/构造函数和析构函数能否为虚函数/" class="article-date">
  	<time datetime="2019-02-18T04:06:21.000Z" itemprop="datePublished">2019-02-18</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/02/18/构造函数和析构函数能否为虚函数/">构造函数和析构函数能否为虚函数</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="C-构造函数和析构函数能否为虚函数？"><a href="#C-构造函数和析构函数能否为虚函数？" class="headerlink" title="C++:构造函数和析构函数能否为虚函数？"></a>C++:构造函数和析构函数能否为虚函数？</h4><ul>
<li>简单结论： <strong>构造函数不能为虚函数，而析构函数可以且有时必须声明为虚函数</strong></li>
</ul>
<ol>
<li><p>构造函数不能为虚函数</p>
<p>C++之父 Bjarne Stroustrup 在《The C++ Programming Language》里是怎么说的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">To construct an object, a constructor needs the exact type of the object it is to create. Consequently, a constructor cannot be virtual. </div><div class="line">Furthermore, a constructor is not quite an ordinary function, In particular, it interacts with memory management in ways ordinary member functions don&apos;t. </div><div class="line">Consequently, you cannot have a pointer to a constructor.</div><div class="line"></div><div class="line">--- From 《The C++ Progamming Language》15.6.2</div></pre></td></tr></table></figure>
<p>翻译如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">要构造一个对象，构造函数需要它要创建的对象的确切类型。因此，构造函数不能是虚的。</div><div class="line">此外，构造函数并不完全是一个普通函数，特别是，它与内存管理的交互方式与普通成员函数不同。</div><div class="line">因此，您不能有指向构造函数的指针。</div></pre></td></tr></table></figure>
<ul>
<li>如果构造函数为虚函数，那么就需要通过vtable来调用，但vtable是在构造函数中才初始化的，而不是在之前。因此，构造函数不能为虚函数。</li>
</ul>
</li>
<li><p>析构函数可以是虚函数 且有时必须是虚函数</p>
<ul>
<li>这就好理解了。因为此时vtable已经初始化了；而且我们通常通过基类的指针来销毁对象，如果析构函数不为虚函数的话，就不能正确识别对象类型，从而不能正确销毁对象。</li>
<li><strong>在用基类指针指向派生类时</strong><ul>
<li>基类指析构函数为virtual的时候,delete基类指针，会有限调用派生类的析构函数，再调用基类的析构函数。</li>
<li>基类指析构函数为不为virtual的时候，delete基类指针，只会调用基类的析构函数，而不会调用派生类的析构函数，这样会造成销毁对象的不安全。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>应该为多态基类声明虚析构函数。一旦一个类包含虚函数，他就应该包含虚析构函数，因为多态性，必定会有基类调用派生类</li>
<li>如果一个类不做基类或者不需要具有多态性，便不应该为它声明虚析构函数。</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/技术，-c/">技术， c++</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/it/">it</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-HashMap" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/02/17/HashMap/" class="article-date">
  	<time datetime="2019-02-17T13:16:21.000Z" itemprop="datePublished">2019-02-17</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/02/17/HashMap/">HashMap</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="HashMap操作："><a href="#HashMap操作：" class="headerlink" title="HashMap操作："></a>HashMap操作：</h4><ul>
<li>put()</li>
<li>get()</li>
<li>数组扩容</li>
</ul>
<h5 id="put"><a href="#put" class="headerlink" title="put()"></a>put()</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;  </div><div class="line">        <span class="keyword">if</span> (key == null)  </div><div class="line">            <span class="keyword">return</span> putForNullKey(value);  </div><div class="line">        <span class="keyword">int</span> hash = hash(key.hashCode());  </div><div class="line">        <span class="keyword">int</span> i = indexFor(hash, table.length);  </div><div class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123;  </div><div class="line">            Object k;  </div><div class="line">            <span class="comment">//判断当前确定的索引位置是否存在相同hashcode和相同key的元素，如果存在相同的hashcode和相同的key的元素，那么新值覆盖原来的旧值，并返回旧值。  </span></div><div class="line">            <span class="comment">//如果存在相同的hashcode，那么他们确定的索引位置就相同，这时判断他们的key是否相同，如果不相同，这时就是产生了hash冲突。  </span></div><div class="line">            <span class="comment">//Hash冲突后，那么HashMap的单个bucket里存储的不是一个 Entry，而是一个 Entry 链。  </span></div><div class="line">            <span class="comment">//系统只能必须按顺序遍历每个 Entry，直到找到想搜索的 Entry 为止——如果恰好要搜索的 Entry 位于该 Entry 链的最末端（该 Entry 是最早放入该 bucket 中），  </span></div><div class="line">            <span class="comment">//那系统必须循环到最后才能找到该元素。  </span></div><div class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;  </div><div class="line">                V oldValue = e.value;  </div><div class="line">                e.value = value;  </div><div class="line">                <span class="keyword">return</span> oldValue;  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">        modCount++;  </div><div class="line">        addEntry(hash, key, value, i);  </div><div class="line">        <span class="keyword">return</span> null;  </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h4 id="hash值冲突"><a href="#hash值冲突" class="headerlink" title="hash值冲突"></a>hash值冲突</h4><ul>
<li><p>冲突发生在put()时</p>
</li>
<li><p>从源码可以看出，hash值是通过<strong>hash(key.hashCode())</strong>来获取的</p>
</li>
<li><p>当put的元素越来越多时，难免会出现不同的key产生相同的hash值问题，也即是hash冲突，</p>
</li>
<li><p>当拿到一个hash值，通过indexFor(hash, table.length)获取数组下标，</p>
</li>
<li><p>先查询是否存在该hash值，</p>
<ul>
<li><p>若不存在，则直接Entry<v,v>的方式存放在数组中，</v,v></p>
</li>
<li><p>若存在，则再对比key是否相同</p>
<ul>
<li>若hash值和key都相同 则替换value</li>
<li>若hash值相同，key不相同，则形成一个单链表，将hash值相同，key不同的元素以Entry<v,v>的方式存在链表中。</v,v></li>
</ul>
</li>
</ul>
</li>
<li><p>这样就解决了hash冲突，这种方法叫做<strong>分离链表法</strong></p>
</li>
</ul>
<h4 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;   </div><div class="line">       <span class="keyword">if</span> (key == null)   </div><div class="line">           <span class="keyword">return</span> getForNullKey();   </div><div class="line">       <span class="keyword">int</span> hash = hash(key.hashCode());   </div><div class="line">       <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];   </div><div class="line">           e != null;   </div><div class="line">           e = e.next) &#123;   </div><div class="line">           Object k;   </div><div class="line">           <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))   </div><div class="line">                <span class="keyword">return</span> e.value;   </div><div class="line">        &#125;   </div><div class="line">        <span class="keyword">return</span> null;   </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li>从HashMap中get元素时，首先计算 key的hashCode,找到数组中对应位置的某一 元素，然后通过key的equals方法在对应位置的链表中找到需要的元素。</li>
<li>当hashMap没有出现hash冲突时，没有形成单向链表，get()方法能够直接定位到元素</li>
<li>当出现冲突后，形成了单向链表，bucket里存放的不在是一个Entry对象，而是一个Entry对象链表，系统只能顺序的遍历每个Entry直到找到想要搜索的Entry为止。</li>
<li>如果恰好搜索的Entry位于该Entry链表的最末端，那循环换必须要进行到最后一步才能找到元素，</li>
<li>此时涉及到一个<strong>负载因子</strong>的概念，hashMap默认的负载因子为0.75，这是考虑到存储空间和查询时间上成本 的一个 折中值：<ul>
<li>增大负载因子，可以减少hash表（就是那个Entry数组）所占的内空间，但会增加查询数据的时间开销，而查询是最频繁的操作（put()和get()都会用到）</li>
<li>减少负载因子，会提高查询时间，但会增加hash表所 占的内空间，</li>
<li>结合以上，阈值（threshold)就是在此负载因子（loadFactor）和容量（capacity)对应下允许的最大元素数目。超过这个数目就重新resize，以降低实际的负载因子。</li>
<li>当容量超出此最大容量时，resize后的HashMap容量是之前的两倍。</li>
</ul>
</li>
</ul>
<h4 id="hashMap数组扩容"><a href="#hashMap数组扩容" class="headerlink" title="hashMap数组扩容"></a>hashMap数组扩容</h4><ul>
<li>当hashMap中元素越来越多时，hash冲突的几率也就越来越高，因为数组的长度是固定的。所以为了提高查询效率，就要对hashMap的数组进行扩容。而在HashMap数组扩容后，最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，并放进去，这 就是<strong>resize</strong>。</li>
<li>那么HashMap什么时候进行扩容呢？当HashMap中的元素个数超过数组大小<em>loadFactor时，就会进行 数组扩容，loadFactor的默认值为0.75，比如数组大小 为16，那么当hashMap中有16X0.75=12的时候就把数组的大小扩展为2</em>X16=32 即扩大 一倍，然后重新计算每个元素在数组中的位置，扩容是需要进行数组复制的，复制数组是非常消耗性能的操作，所以如果我们已经阈值HashMap中的元素个数，那么预设元素的个数能有效的提高HashMap的性能。</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/技术，-数据结构/">技术， 数据结构</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/it/">it</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Epoll" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/02/15/Epoll/" class="article-date">
  	<time datetime="2019-02-15T08:16:21.000Z" itemprop="datePublished">2019-02-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/02/15/Epoll/">epoll</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="epoll相对其他模型-select-poll-做的改进："><a href="#epoll相对其他模型-select-poll-做的改进：" class="headerlink" title="epoll相对其他模型(select,poll)做的改进："></a>epoll相对其他模型(select,poll)做的改进：</h4><ul>
<li>支持一个进程打开较大数目的文件描述符（fd）<ul>
<li>select模型对一个进程所打开的文件描述符是有一定限制的。其由FD_SIZE设置，默认为1024/2048。这对于那么需要支持上万连接数目的高并发服务器来说显然太少了，这个时候可以选择两种方案：<ul>
<li>（1）可以修改FD_SETSIZE宏然后重新编译内核，不过这样做也不会带来网络效率的下降；</li>
<li>（2）可以选择多进程的解决方案（传统的Apache方案），不过虽然Linux中创建线程的代价比较小，但仍然是不可忽视的，加上进程间数据同步远不及线程间同步的高效，所以也不是一种完美的方案。</li>
</ul>
</li>
<li>但是，epoll则没有对描述符数目的限制，它所支持的文件描述符上限是整个系统最大可以打开的文件数目。例如，在1GB内存的机器上，这个限制大概为10万左右。</li>
</ul>
</li>
<li>io效率不会随文件描述符（fd）的增加而线性下降<ul>
<li>传统的select/poll的一个致命的弱点就是当你拥有一个很大的socket集合时，不过任一时间只有部分socket是活跃的，select/poll每次调用都会线性扫描整个socket集合，这导致IO处理效率呈现线性下降</li>
<li>但是epoll不存在这个问题。它只会对活跃的socket进行操作，这是因为在内核实现中，epoll是根据每个fd上面的callback函数实现的。因此。只有活跃的socket才会主动条用callback函数，其他idle状态的socket则不会。在这一点上,epoll实现了一个伪AIO(异步IO),其内部推动力在内核。</li>
<li>在一些实际情况中。如果所有的socket基本上都是活跃的，如高速LAN环境，epoll并不比select/poll效率高，相反，过多使用epoll_ctl,其效率反而还有稍微下降。但是，一旦使用idle connections模拟WAN环境,epoll的效率就远在select/poll之上了。</li>
</ul>
</li>
<li>使用<strong>mmap</strong>加速内核与用户空间的消息传递<ul>
<li>无论是select还是poll，它们都需要内核把fd消息通知给用户空间。因此，如何避免不必要的内存拷贝就很重要了。</li>
<li>对于该问题，epoll通过内核与用户空间mmap同一块内存来实现。</li>
</ul>
</li>
</ul>
<h4 id="epoll-API"><a href="#epoll-API" class="headerlink" title="epoll API"></a>epoll API</h4><ul>
<li><p>epoll只有epoll_create,epoll_ctl,epoll_wait这三个系统调用。其定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">struct</span> epoll_event *events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</div></pre></td></tr></table></figure>
</li>
</ul>
<ol>
<li><strong>epoll_create</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</div></pre></td></tr></table></figure>
<ul>
<li>调用epoll_create犯法创建一个epoll的句柄</li>
<li>注意：当创建好epoll句柄后，它就会占用一个fd。在使用完epoll后 必须调用close函数进行关闭 否则会导致fd耗尽。</li>
</ul>
<ol>
<li><p><strong>epoll_ctl</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">struct</span> epoll_event *event)</span></span>;</div></pre></td></tr></table></figure>
<p>epoll的时间注册函数，它不同于select是在监听事件时告诉内核要监听什么类型的事件，而是通过</p>
<p>epoll_ctl 注册要监听的事件类型。</p>
</li>
</ol>
<ul>
<li><p>第一个参数epfd： epoll_create函数的返回值(epoll句柄)</p>
</li>
<li><p>第二个参数events：表示动作类型。有三个宏来表示：</p>
<ul>
<li>EPOLL_CTL_ADD  : 注册新的fd到epfd中；</li>
<li>EPOLL_CTL_MOD : 修改已经注册的fd的监听事件</li>
<li>EPOLL_CTL_DEL   : 从epfd中删除一个fd</li>
</ul>
</li>
<li><p>第三个参数fd： 需要监听的fd</p>
</li>
<li><p>第四个参数event： 告诉内核需要监听什么事件</p>
</li>
<li><p>struct epoll_event结构体如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 保存触发事件的某个文件描述符相关的数据</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> epoll_data&#123;</div><div class="line">    <span class="keyword">void</span> *ptr;</div><div class="line">    <span class="keyword">int</span> fd;</div><div class="line">    <span class="keyword">__uint32_t</span> u32;</div><div class="line">    <span class="keyword">__uint64_t</span> u64;</div><div class="line">&#125; <span class="keyword">epoll_data_t</span>;</div><div class="line"></div><div class="line"><span class="comment">// 感兴趣的事件和被触发的事件</span></div><div class="line"><span class="keyword">struct</span> epoll_event&#123;</div><div class="line">    <span class="keyword">__uint32_t</span> events; <span class="comment">// Epoll events</span></div><div class="line">    <span class="keyword">epoll_data_t</span> data; <span class="comment">// User data variable</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>如上所示，对于Epoll events， 其可以是一下几个宏的集合：</p>
<ul>
<li>EPOLLIN    : 表示对应的文件描述符可读（包括对端的socket）;</li>
<li>EPOLLOUT: 表示对应的文件描述符可写；</li>
<li>EPOLLPRI  : 表示对应的文件描述符有紧急数据可读（带外数据）；</li>
<li>EPOLLERR : 表示对应的文件描述符发生错误；</li>
<li>EPOLLHUP: 表示对应的文件描述符被挂断；</li>
<li>EPOLLET    : 将EPOLL设为边缘触发(Edge Triggered), 这是相对于水平触发(Level Triggered)而言的。</li>
<li>EPOLLSHOT: 只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket,需要再次注册</li>
</ul>
</li>
</ul>
<ol>
<li><p><strong>epoll_wait</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">struct</span> epoll_event *events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</div></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li><p>收集在epoll监听的事件中已经发生的事件。</p>
<ul>
<li><p>第一个参数epfd： epoll_create函数的返回值(epoll句柄)</p>
</li>
<li><p>第二个参数events：分配好的epoll_event结构体数组，epoll将会把发生的事件赋值到events数组中</p>
<p>（注意： events不可以是空指针，内核只负责把数据赋值到这个event数组中。不会去帮助我们在用户态分配内存）</p>
</li>
<li><p>第三个参数maxevents：告诉内核这个events数组有多大，这个maxevents的值不能大于创建epoll_create时的size。 </p>
</li>
<li><p>第四个参数timeout：超时时间（毫秒）。如果函数调用成功，则返回对应IO上已准备好的文件描述符的数目，如果返回0则表示已经超时。</p>
</li>
</ul>
</li>
</ul>
<h4 id="epoll-工作模式"><a href="#epoll-工作模式" class="headerlink" title="epoll 工作模式"></a>epoll 工作模式</h4><ol>
<li>LT模式(Level Triggered, 水平触发)<ul>
<li>该模式是epoll的缺省工作模式，其同时支持阻塞和非阻塞socket。内核会告诉开发者一个文件描述符是否就绪，如果开发者不采取任何操作，内核仍然会一直通知。</li>
</ul>
</li>
<li>ET模式(Edge Triggered, 边缘触发)<ul>
<li>该模式是一种高速处理模式，当且仅当状态发生变化时才会获得通知。在该模式下，其假定开发者在接收到一次通知后，会完整的处理该事件，因此内核将不再通知这一事件。</li>
<li>注意，缓冲区中还有未处理的数据不能说是状态变化，因此，在ET模式下，开发者如果只读取了一部分数据，其将再也得不到通知了。正确的做法是，开发者自己确认读完了所有的字节(一直调用read/write直到出错EAGAGIN为止)</li>
<li>Nginx默认采用的就是ET(边缘触发)</li>
</ul>
</li>
</ol>
<h3 id="epoll高效性原因："><a href="#epoll高效性原因：" class="headerlink" title="epoll高效性原因："></a>epoll高效性原因：</h3><ol>
<li><p>select/poll每次调用都要传递所要箭筒的所有fd给select/poll系统调用，这意味着每次调用select/poll时都要将fd列表从用户空间拷贝到内核，当fd数目很多时，这会造成性能低效。</p>
<p>对于epoll_wait,每次调用epoll_wait时，其不需要将fd列表传递给内核，epoll_ctl不需要每次都拷贝所有的fd列表，只需要进行增量式操作。因此。在调用epoll_create函数之后，内核已经开始准备数据接口用于存放需要监控的fd了。其后，每次epoll_ctl只是对这个数据结构进行简单的维护操作即可。</p>
</li>
<li><p>内核使用<strong>slab机制</strong>，为epoll提供了快速的数据结构。在内核里，一切都是文件。因此，epoll向内核注册了一个文件系统，用于存储所有被监控的fd。当调用epoll_create时，就会在这个虚拟的epoll文件系统中创建file节点。epoll在被内核初始化时，同时会分配出epoll自己的内核高速cache区，用于存放每个我们希望监控的fd。这些fd会以<strong>红黑树</strong>的形式保存在内核cache里，以支持快速查找、插入和删除。这个内核高速cache,就是建立连续的物理内存页，然后在之上建立slab层，简单的说，就是物理上分配好想要的size的内存对象，每次使用都使用空闲的已分配好的对象</p>
</li>
<li><p>当调用epoll_ctl往epfd注册百万个fd时，epoll_wait仍然能够快速返回，并有效的讲发生的时间fd返回给用户。原因在于，当我们调用epoll_create时，内核除了帮我们在epoll文件系统新建file节点，同时在内核cache创建红黑树用于存储以后由epoll_ctl传入的fd外，还会再建立一个<strong>list链表</strong>，用于存储准备就绪的事**件。当调用epoll_wait时，仅仅观察这个list链表中有无数据即可。如果list链表中有数据，则返回这个链表中的所有元素；如果list链表中没有数据，则sleep然后等到timeout超时返回。所以，epoll_wait非常高效，而且，通常情况下，即使我们需要监控百万级的fd,但大多数情况下，一次也只返回少量准备就绪的fd而已。因此，每次调用epoll_wait,其仅需要从内核态复制少量的fd到用户空间而已。</p>
<p>那么，这个准备继续的list链表是怎么维护的呢？过程如下：</p>
<p>当我们支持epoll_ctl时，除了把fd放入到epoll文件系统里file对象对应的红黑树之外，还会<strong>给内核中断处理程序注册一个回调函数</strong>，其告诉内核，如果这个fd的中断到了，就把它放到准备就绪的list链表中。</p>
<p>如此，一颗红黑树、一张准备就绪的fd链表以及少量的内存cache，就帮我们解决了高并发下fd的处理问题。</p>
</li>
</ol>
<ul>
<li>总结一下：<ul>
<li>执行epoll_create时，创建了红黑树和就绪list链表。</li>
<li>执行epoll_ctl时，如果增加fd,则检查在红黑树中是否存在，存在则立即返回，不存在则添加到红黑树中，然后向内核注册回调函数，用于当中断事件到来时向准备就绪的list链表中插入数据。</li>
<li>执行epoll_wait时立即返回准备就绪链表里的数据即可。</li>
</ul>
</li>
</ul>
<h4 id="epoll应用实例"><a href="#epoll应用实例" class="headerlink" title="epoll应用实例:"></a>epoll应用实例:</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/epoll.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netinet/in.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 5</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> OPEN_MAX 100</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> LISTENQ 20</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 5000</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> INFTIM 1000</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">setnonblocking</span><span class="params">(<span class="keyword">int</span> sock)</span></span>&#123; <span class="comment">// 将套接字设置为非阻塞</span></div><div class="line">    <span class="keyword">int</span> opts;</div><div class="line">    opts=fcntl(sock, F_GETFL);</div><div class="line">    <span class="keyword">if</span>(opts&lt;<span class="number">0</span>)&#123;</div><div class="line">        perror(<span class="string">"fcntl(sock,F_GETFL) error"</span>);</div><div class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    opts=opts|O_NONBLOCK;</div><div class="line">    <span class="keyword">if</span>(fcntl(sock,F_SETFL,opts)&lt;<span class="number">0</span>)&#123;</div><div class="line">        perror(<span class="string">"fcntl(sock,F_SETFL) error"</span>);</div><div class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> i, maxi, listenfd, connfd, sockfd, epfd, nfds, portnumber;</div><div class="line">    <span class="keyword">ssize_t</span> n;</div><div class="line">    <span class="keyword">char</span> line[MAXLINE];</div><div class="line">    <span class="keyword">socklen_t</span> clilen;</div><div class="line">    <span class="keyword">if</span>(<span class="number">2</span> == argc)&#123;</div><div class="line">        <span class="keyword">if</span>((portnumber = atoi(argv[<span class="number">1</span>]))&lt;<span class="number">0</span>)&#123;</div><div class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Usage:%s portnumber/a/n"</span>, argv[<span class="number">0</span>]);</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Usage:%s portnumber/a/n"</span>, argv[<span class="number">0</span>]);</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">   </div><div class="line">    <span class="comment">// epoll_event结构体 ev用于注册事件(epoll_ctl) events数组用于回传要处理的事件(epoll_wait)</span></div><div class="line">    <span class="keyword">struct</span> epoll_event ev, events[<span class="number">20</span>];</div><div class="line">    epfd=epoll_create(<span class="number">256</span>);</div><div class="line">    <span class="keyword">struct</span> sockaddr_in clientaddr;</div><div class="line">    <span class="keyword">struct</span> sockaddr_in serveraddr;</div><div class="line">    listenfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</div><div class="line">    setnonblocking(listenfd);</div><div class="line">    ev.data.fd=listenfd;</div><div class="line">    ev.events=EPOLLIN|EPOLLET;</div><div class="line">    </div><div class="line">    epoll_ctl(epfd, EPOLL_CTL_ADD, listenfd, &amp;ev);</div><div class="line">    bzero(&amp;serveraddr, <span class="keyword">sizeof</span>(serveraddr));</div><div class="line">    serveraddr.sin_family = AF_INET;</div><div class="line">    <span class="keyword">char</span> *local_addr = <span class="string">"127.0.0.1"</span>;</div><div class="line">    inet_aton(local_addr, &amp;(serveraddr.sin_addr));</div><div class="line">    serveraddr.sin_port=htons(portnumber);</div><div class="line">    bind(listenfd, (sockaddr*)&amp;serveraddr, <span class="keyword">sizeof</span>(serveraddr));</div><div class="line">    listen(listenfd, LISTENQ);</div><div class="line">    maxi = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(;;)&#123;</div><div class="line">        <span class="comment">//返回对应IO上已准备好的文件描述符数目，为0则无准备就绪的fd</span></div><div class="line">        nfds=epoll_wait(epfd,events,<span class="number">20</span>,<span class="number">500</span>);</div><div class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;nfds;++i)&#123;</div><div class="line">            <span class="comment">// 如果监测到有一个socket用户连接到了绑定socket端口，建立新的连接</span></div><div class="line">            <span class="keyword">if</span>(events[i].data.fd==listenfd)&#123; </div><div class="line">                connfd = accept(listenfd, (sockaddr*)&amp;clientaddr, &amp;clilen);</div><div class="line">                <span class="keyword">if</span>(connfd&lt;<span class="number">0</span>)&#123;</div><div class="line">                    perror(<span class="string">"connfd&lt;0"</span>);</div><div class="line">                    <span class="built_in">exit</span>(<span class="number">1</span>);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">char</span> *str = inet_ntoa(clientaddr.sin_addr);</div><div class="line">                <span class="built_in">cout</span>&lt;&lt; <span class="string">"accept a connection from "</span>&lt;&lt;str&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">                ev.data.fd=connfd;</div><div class="line">                ev.events=EPOLLIN|EPOLLET;</div><div class="line">                epoll_ctl(epfd, EPOLL_CTL_ADD, connfd, &amp;ev);</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(events[i].events&amp;EPOLLIN)&#123;<span class="comment">//如果已连接的用户，并且收到数据，那么进行读入</span></div><div class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"EPOLLIN"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">                <span class="keyword">if</span>((sockfd=events[i].data.fd)&lt;<span class="number">0</span>)</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                <span class="keyword">if</span>((n = read(sockfd, line, MAXLINE))&lt;<span class="number">0</span>)&#123;</div><div class="line">                    <span class="keyword">if</span>(errno == ECONNRESET)&#123;</div><div class="line">                        close(sockfd);</div><div class="line">                        events[i].data.fd = <span class="number">-1</span>;</div><div class="line">                    &#125; <span class="keyword">else</span></div><div class="line">                        <span class="built_in">cout</span>&lt;&lt;<span class="string">"readline error"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</div><div class="line">                    close(sockfd);</div><div class="line">                    events[i].data.fd = <span class="number">-1</span>;</div><div class="line">                &#125;</div><div class="line">                line[n] = <span class="string">'\0'</span>;</div><div class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"read data: "</span>&lt;&lt;line&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">                ev.data.fd=sockfd;</div><div class="line">                ev.events=EPOLLOUT|EPOLLET;</div><div class="line">                epoll_ctl(epfd, EPOLL_CTL_MOD, sockfd, &amp;ev);</div><div class="line">                <span class="comment">//读完后将sockfd上要处理的事件修改为可写EPOLLOUT</span></div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(events[i].events&amp;EPOLLOUT)&#123;<span class="comment">//如果有数据发送。则进行写入</span></div><div class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"EPOLLOUT"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">                sockfd=events[i].data.fd;</div><div class="line">                write(sockfd, line, n);</div><div class="line">                ev.data.fd=sockfd;</div><div class="line">                ev.events=EPOLLIN|EPOLLET;</div><div class="line">                epoll_ctl(epfd, EPOLL_CTL_MOD, sockfd, &amp;ev); </div><div class="line">                <span class="comment">//写完后将sockfd上要处理的事件修改为可读EPOLLIN</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 测试步骤如下：</span></div><div class="line"><span class="comment">// 1 编译 g++ -o test test.cpp </span></div><div class="line"><span class="comment">// 2 执行 ./test 7000</span></div><div class="line"><span class="comment">// 3 nc 127.0.0.1 7000 然后输入内容</span></div></pre></td></tr></table></figure>
<h4 id="扩展知识点"><a href="#扩展知识点" class="headerlink" title="扩展知识点"></a>扩展知识点</h4><ol>
<li>mmap [内核与用户空间的内存映射]</li>
<li>slab[内存池 对象池 解决内部碎片问题]</li>
<li>红黑树[降低查询深度 加快查询速度]</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/技术，linux/">技术，linux</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/it/">it</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-红黑树" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/02/15/红黑树/" class="article-date">
  	<time datetime="2019-02-15T08:16:21.000Z" itemprop="datePublished">2019-02-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/02/15/红黑树/">红黑树</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="红黑树特点："><a href="#红黑树特点：" class="headerlink" title="红黑树特点："></a>红黑树特点：</h4><ol>
<li><p>每个节点或者是黑色，或者是红色</p>
</li>
<li><p>跟节点是黑色</p>
</li>
<li><p>每个叶子节点（NIL）是黑色</p>
</li>
<li><p>如果一个节点是红色的，则它的子节点必须是黑色的</p>
</li>
<li><p>从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">注意</div><div class="line">特性（3）中的叶子节点，是职位空（NIL或者NULL）的节点</div><div class="line">特性（5）确保没有一条路径会比其他路径长出2倍。因而，红黑树是相对接近平衡的二叉树</div></pre></td></tr></table></figure>
<ul>
<li><p>红黑树的时间复杂度为：o(lgn)</p>
</li>
<li><p>定理：一个含有n个节点的红黑树的高度至多为2log(n+1)</p>
</li>
</ul>
<h4 id="红黑树的操作："><a href="#红黑树的操作：" class="headerlink" title="红黑树的操作："></a>红黑树的操作：</h4><ol>
<li>左旋和右旋<ul>
<li>旋转的目的是让树保持红黑树的特性。</li>
</ul>
</li>
<li>添加<ul>
<li>第一步：将红黑树当做一颗二叉查找树，将节点插入</li>
<li>第二步：将插入的节点着色为“红色”</li>
<li>第三步：通过一系列的旋转和着色等操作，使之重新成为一颗红黑树</li>
</ul>
</li>
<li>删除<ul>
<li>第一步：将红黑树当做一颗二叉查找树，将节点删除</li>
<li>第二步：通过“旋转和重新着色”等一系列操作来修正该树，使之重新成为一颗红黑树</li>
</ul>
</li>
</ol>
<h4 id="红黑树应用："><a href="#红黑树应用：" class="headerlink" title="红黑树应用："></a>红黑树应用：</h4><p><code>主要用它来存储有序的数据 它查询时间复杂度为o(lgn)非常高效</code></p>
<ul>
<li>C++的STL中 map和set都是用红黑树实现的</li>
<li>linux进程调度(Completely Fair Scheduler) 用红黑树管理进程控制块</li>
<li>epoll在内核中的实现，用红黑树管理事件块</li>
<li>nginx中，用红黑树管理timer等</li>
<li>java的TreeSet和TreeMap实现</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/技术，-数据结构/">技术， 数据结构</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/it/">it</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Travel" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/12/12/Travel/" class="article-date">
  	<time datetime="2018-12-12T03:02:15.000Z" itemprop="datePublished">2018-12-12</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/12/Travel/">Travel</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="/2018/12/12/Travel/宝安公园.jpg" alt="宝安公园"><br><img src="/2018/12/12/Travel/凤凰山.jpg" alt="凤凰山"><br><img src="/2018/12/12/Travel/莲花山.jpg" alt="莲花山"><br><img src="/2018/12/12/Travel/平峦山.jpg" alt="平峦山"><br><img src="/2018/12/12/Travel/铁仔山.jpg" alt="铁仔山"><br><img src="/2018/12/12/Travel/西湾红树林.jpg" alt="西湾红树林"></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/life/">life</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Family" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/09/30/Family/" class="article-date">
  	<time datetime="2018-09-30T09:29:33.000Z" itemprop="datePublished">2018-09-30</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/30/Family/">Family</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="/2018/09/30/Family/2019年饭.jpg" alt="2019年饭"><br><img src="/2018/09/30/Family/baby-3.jpg" alt="baby-3"><br><img src="/2018/09/30/Family/baby-2.jpg" alt="baby-2"><br><img src="/2018/09/30/Family/baby-1.jpg" alt="baby-1"><br><img src="/2018/09/30/Family/hainan.jpg" alt="hainan"><br><img src="/2018/09/30/Family/marry.jpg" alt="marry"></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/life/">life</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-麻将算法" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/01/16/麻将算法/" class="article-date">
  	<time datetime="2018-01-16T08:20:28.000Z" itemprop="datePublished">2018-01-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/16/麻将算法/">麻将算法</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>代码路径：<a href="https://github.com/yuanfengyun/qipai/tree/master/mjlib_lua/split" target="_blank" rel="external">https://github.com/yuanfengyun/qipai/tree/master/mjlib_lua/split</a></p>
<p>传统拆分法(不带赖子）<br>1、收集能做将的所有牌作为集合A<br>2、遍历每种能做将的牌，扣除后，判断剩余牌是否能胡<br>判断方法：遍历每种花色，从1到9按以下规则处理<br>a、如果遇到牌张数为0，continue<br>b、张数为1，判断以否扣除一坎牌，比如有一个2万，判断是否能组成2，3，4万，如果不能，则证明选择的这组将不能胡牌，break<br>c、张数为2，判断是否能扣除二坎牌，比如有2个6万，判断是否有7个七万和两个八万，如果不能，则证明选择的这组将不能胡牌 break<br>d、张数为3，直接扣除一个刻子<br>e、张数为4，扣除一个刻子后，判断是否能组成一坎牌，比如4个5万，先扣除3个5万，然后判断是否有5，6万各一张，如果有，则能组成三个四万，4，5，6万这两组牌，如果不能，则证明选择的这组将不能胡牌 break</p>
<p>示例：</p>
<p>1112345678999九莲宝灯牌型，判断是否能胡5万<br>1、将5万加入牌中, 11123455678999<br>2、选择将: 1万，5万，9万(大于等于2张的牌才能做将）</p>
<p>3、选择1万做将,剩余 123455678999<br>a、123455678999, 首部是1张1万，扣除123万，剩余455678999<br>b、455678999，首部是1张4万，扣除456万，剩余578999<br>c、578999，首部是1张5万，无法扣除567万，break</p>
<p>4、选择5万做将，剩余111234678999<br>a、111234678999，首部是3张1万，直接扣除，剩余234678999<br>b、234678999，首部是1张2万，扣除234，剩余678999<br>c、678999，首部是1张6万，扣除678，剩余999<br>d、999, 首部是3张9万，直接扣除，所有牌能拆完，胡牌</p>
<p>带赖子版本：<br>带赖子版本思路和传统拆分算法差不多，对1，3，4张牌的处理是完全一样的。<br>只是对于牌数量是2时，不能再直接拆222的组合，需要根据后面牌的情况，进行分类讨论<br>思路是一个赖子置换的贪心算法：</p>
<p>比如：<br>  当前是一个1万，<br>  如果我把这个1万配成一个刻子，需要2个赖子<br>  如果配成顺子的话，最坏c1=0,c2=0需要2个赖子，<br>  如果c1,c2中有一个不为0，则我只需要1个赖子，就可以配成顺子<br>  如果c1,c2中都不为0，则我不需要赖子就可以拆出顺子来, 这样可以节省两个赖子给后面的牌用</p>
<p>记号c，c1，c2，c3, c4分别表示当前牌个数，当前牌的后一张牌个数，后两张，后三张, 后四张牌的个数<br>比如 1万1万2万3万3万4万。c=2， c1=1, c2=2, c3=1, c4=0</p>
<p>具体分类如下：<br>c1 == 0 , 此时牌为20，如果拆222至少需要2个赖子，而拆3则只需要一张赖子，剩下胡赖子可以省下给后面用<br>c1 == 1 ，此时牌为21，需要根据后面的c2，c3来判断是拆刻子还是222，具体见代码<br>c2 == 2 , 此时牌为22, 如果拆33，需要2个赖子，拆222的话，可能需要0，1，2个赖子，选择拆222<br>c2 == 3 , c2 == 4的情况，见代码</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/it/">it</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2019 ahuang
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: /
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>